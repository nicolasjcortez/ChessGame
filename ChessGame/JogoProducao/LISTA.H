#if ! defined( LISTA_ )

#define LISTA_

/***************************************************************************
 *
 *  $MCD M√≥dulo de defini√ß√£o: LIS  Lista duplamente encadeada
 *
 *  Arquivo gerado:              LISTA.h
 *  Letras identificadoras:      LIS
 *
 *  Nome da base de software:    Arcabou√ßo para a automa√ß√£o de testes de programas redigidos em C
 *  Arquivo da base de software: D:\AUTOTEST\PROJETOS\LISTA.BSW
 *
 *  Projeto: INF 1301 / 1628 Automatiza√ß√£o dos testes de m√≥dulos C
 *  Gestor:  LES/DI/PUC-Rio
 *  Autores: av
 *
 *  $HA Hist√≥rico de evolu√ß√£o:
 *     Vers√£o  Autor    Data    Observa√ß√µes
 *     4       avs   01/fev/2006 criar linguagem script simb√≥lica
 *     3       avs   08/dez/2004 uniformiza√ß√£o dos exemplos
 *     2       avs   07/jul/2003 unifica√ß√£o de todos os m√≥dulos em um s√≥ projeto
 *     1       avs   16/abr/2003 in√≠cio desenvolvimento
 *
 *  $ED Descri√ß√£o do m√≥dulo
 *     Implementa listas gen√©ricas duplamente encadeadas.
 *     Podem existir n listas em opera√ß√£o simultaneamente.
 *     As listas possuem uma cabe√ßa encapsulando o seu estado.
 *
 *     Cada lista √© homog√™nea quanto ao tipo dos dados que armazena.
 *     Cada elemento da lista referencia o valor que cont√©m.
 *
 *     Os ponteiros para os dados s√£o copiados para elementos da lista.
 *        N√£o √© copiado o valor apontado por estes ponteiros.
 *
 *     O controle da destrui√ß√£o do valor de um elemento a ser exclu√≠do
 *        √© realizado por uma fun√ß√£o fornecida pelo usu√°rio.
 *
 *     Cada lista referencia uma fun√ß√£o que determina como devem ser
 *        desalocados os dados nela contidos.
 *
 *     A fun√ß√£o de libera√ß√£o dos valores contidos nos elementos deve
 *        assegurar a libera√ß√£o de todos os espa√ßos refer√™nciados pelo
 *        valor contido em um elemento.
 *        Esta fun√ß√£o √© chamada antes de se desalocar um elemento
 *        de uma lista.
 *        Caso n√£o seja necess√°rio desalocar o valor referenciado pelo
 *        elemento, o ponteiro para a fun√ß√£o de libera√ß√£o poder√° ser NULL .
 *        Caso o elemento da lista seja a √∫nica √¢ncora do valor referenciado,
 *        esta fun√ß√£o deve promover a destrui√ß√£o (free) desse valor e
 *        de todos os dados nele ancorados.
 *
 ***************************************************************************/



#if defined( LISTA_OWN )
    #define LISTA_EXT
#else
     #define LISTA_EXT extern
#endif



/***** Declara√ß√µes exportadas pelo m√≥dulo *****/



/* Tipo refer√™ncia para uma lista */



typedef struct LIS_tagLista * LIS_tppLista ;





/***********************************************************************
 *
 *  $TC Tipo de dados: LIS Condi√ß√µes de retorno
 *
 *
 *  $ED Descri√ß√£o do tipo
 *     Condi√ß√µes de retorno das fun√ß√µes da lista
 *
 ***********************************************************************/



typedef enum {
    
    
    
    LIS_CondRetOK  = 1,
    
    /* Concluiu corretamente */
    
    
    
    LIS_CondRetListaVazia = 2,
    
    /* A lista n√£o cont√©m elementos */
    
    
    
    LIS_CondRetFimLista = 3,
    
    /* Foi atingido o fim de lista */
    
    
    
    LIS_CondRetNaoAchou = 4 ,
    
    /* N√£o encontrou o valor procurado */
    
    
    
    LIS_CondRetFaltouMemoria = 5,
    
    /* Faltou mem√≥ria ao tentar criar um elemento de lista */
    
    LIS_CondRetErroEstrutura = 6
    
    /* Erro na estutura lista */
    
    
    
} LIS_tpCondRet ;


/***********************************************************************
*
*  $TC Tipo de dados: ARV Modos de deturpar
*
*
***********************************************************************/

#ifdef _DEBUG

   typedef enum {

         DeturpaFreeCorrente        =  1 ,
               /* Elemina(free) corrente sem atualizar arestas */

         DeturpaEliminaCorrente          =  2 ,
               /* Elemina(sem free) corrente sem atualizar arestas */

         DeturpaPtAntNulo      =  3 ,
               /* atribui NULL ao ponteiro irm„o ‡ esquerda */

         DeturpaPtProxNulo          =  4 ,
               /* atribui NULL ao ponteiro irm„o ‡ direita */

         DeturpaPtAntLixo      =  5 ,
               /* atribui ponteiro para lixo ao ponteiro irm„o ‡ esquerda */

         DeturpaPtProxLixo            =  6 ,
               /* atribui ponteiro para lixo ao ponteiro irm„o ‡ direita */

         DeturpaCorrenteNulo      =  7 ,
               /* atribui NULL ao ponteiro corrente */

         DeturpaCorrenteLixo         =  8 ,
               /* atribui ponteiro para lixo ao ponteiro corrente */

         DeturpaOrigemNula         =  9 ,
               /* atribui NULL ao ponteiro origem */

         DeturpaOrigemLixo         = 10 ,
               /* atribui ponteiro para lixo ao ponteiro origem */

         DeturpaPtValorNulo      = 11 ,
               /* atribui NULL ao ponteiro valor do nÛ corrente */

         DeturpaPtValorLixo         = 12 ,
               /* atribui ponteiro para lixo ao ponteiro valor do nÛ corrente */

         DeturpaFimNulo        = 13 ,
               /* atribui NULL ao ponteiro fim*/

         DeturpaFimLixo         = 14 ,
               /*  atribui ponteiro para lixo ao ponteiro fim */

         DeturpaTipoCabeca             = 15 ,
               /* Modifica o tipo da cabeÁa */

         DeturpaPtCabecaNulo     = 16 ,
               /* atribui NULL ao ponteiro cabeca */

         DeturpaPtCabecaLixo         = 17,
               /*  atribui ponteiro para lixo ao ponteiro cabeca */
               
         DeturpaTipoElem         = 18
               /* Modifica o tipo do elemento corrente*/

   } LIS_tpModosDeturpacao ;

#endif


/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Criar lista
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Cria uma lista gen√©rica duplamente encadeada.
 *     Os poss√≠veis tipos s√£o desconhecidos a priori.
 *     A tipagem √© implicita.
 *     N√£o existe identificador de tipo associado √† lista.
 *
 *  $EP Par√¢metros
 *     ExcluirValor  - ponteiro para a fun√ß√£o que processa a
 *                     exclus√£o do valor referenciado pelo elemento
 *                     a ser exclu√≠do.
 *                     Ver descri√ß√£o do m√≥dulo.
 *
 *  $FV Valor retornado
 *     Se executou corretamente retorna o ponteiro para a lista.
 *     Este ponteiro ser√° utilizado pelas fun√ß√µes que manipulem esta lista.
 *
 *     Se ocorreu algum erro, por exemplo falta de mem√≥ria ou dados errados,
 *     a fun√ß√£o retornar√° NULL.
 *     N√£o ser√° dada mais informa√ß√£o quanto ao problema ocorrido.
 *
 ***********************************************************************/



LIS_tppLista LIS_CriarLista(
                            
                            void   ( * ExcluirValor ) ( void * pDado ) ) ;





/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Destruir lista
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Destr√≥i a lista fornecida.
 *     O par√¢metro ponteiro para a lista n√£o √© modificado.
 *     Se ocorrer algum erro durante a destrui√ß√£o, a lista resultar√°
 *     estruturalmente incorreta.
 *     OBS. n√£o existe previs√£o para poss√≠veis falhas de execu√ß√£o.
 *
 *  $FV Valor retornado
 *     LIS_CondRetOK    - destruiu sem problemas
 * 
 ***********************************************************************/



void LIS_DestruirLista( LIS_tppLista pLista ) ;





/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Esvaziar lista
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Elimina todos os elementos, sem contudo eliminar a lista
 *
 *  $EP Par√¢metros
 *     pLista - ponteiro para a lista a ser esvaziada
 *
 ***********************************************************************/



void LIS_EsvaziarLista( LIS_tppLista pLista ) ;




/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Inserir elemento antes
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Insere novo elemento antes do elemento corrente.
 *     Caso a lista esteja vazia, insere o primeiro elemento da lista.
 *
 *  $EP Par√¢metros
 *     pLista - ponteiro para a lista onde deve ser inserido o elemento
 *     pValor - ponteiro para o valor do novo elemento
 *              Pode ser NULL
 *
 *  $FV Valor retornado
 *     LIS_CondRetOK
 *     LIS_CondRetFaltouMemoria
 *
 ***********************************************************************/



LIS_tpCondRet LIS_InserirElementoAntes( LIS_tppLista pLista ,
                                       
                                       void * pValor        ) ;





/**********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Inserir elemento ap√≥s
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Insere novo elemento ap√°s o elemento corrente.
 *     Caso a lista esteja vazia, insere o primeiro elemento da lista.
 *
 *  $EP Par√¢metros
 *     Par√¢metros
 *        pLista - ponteiro para a lista onde deve ser inserido o elemento
 *        pValor - ponteiro para o valor do novo elemento
 *                 Pode ser NULL
 *
 *
 *  $FV Valor retornado
 *     Valor retornado
 *        LIS_CondRetOK
 *        LIS_CondRetFaltouMemoria
 *
 ***********************************************************************/



LIS_tpCondRet LIS_InserirElementoApos( LIS_tppLista pLista ,
                                      
                                      void * pValor        )

;




/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Excluir elemento
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Exclui o elemento corrente da lista dada.
 *     Se existir o elemento aa esquerda do corrente ser√° o novo corrente
 *     Se n√£o existir e existir o elemento √† direita, este se tornar√° corrente.
 *     Se este tamb√©m n√£o existir a lista tornou-se vazia.
 *
 *  $EP Par√¢metros
 *     pLista    - ponteiro para a lista na qual deve excluir.
 *
 *  $FV Valor retornado
 *     LIS_CondRetOK
 *     LIS_CondRetListaVazi
 *
 ***********************************************************************/



LIS_tpCondRet LIS_ExcluirElemento( LIS_tppLista pLista ) ;





/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Obter refer√™ncia para o valor contido no elemento
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Obtem a refer√™ncia para o valor contido no elemento corrente da lista
 *
 *  $EP Par√¢metros
 *     pLista - ponteiro para a lista de onde se quer o valor
 *
 *  $FV Valor retornado
 *     n√£o NULL - se o elemento corrente existe
 *     NULL     - se a lista estiver vazia
 *                Pode retornar NULL se o valor inserido no elemento for NULL.
 * 
 ***********************************************************************/



void * LIS_ObterValor( LIS_tppLista pLista ) ;




/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Ir para o elemento inicial
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Torna corrente o primeiro elemento da lista
 *     Faz nada se a lista est√° vazia.
 *
 *  $EP Par√¢metros
 *     pLista - ponteiro para a lista a manipular
 *
 ***********************************************************************/



void LIS_IrInicioLista( LIS_tppLista pLista ) ;





/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Ir para o elemento final
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Torna corrente o elemento final da lista.
 *     Faz nada se a lista est√° vazia.
 *
 *  $EP Par√¢metros
 *     pLista - ponteiro para a lista a manipular
 * 
 ***********************************************************************/



void LIS_IrFinalLista( LIS_tppLista pLista ) ;





/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Avan√ßar elemento
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Avan√ßa o elemento corrente numElem elementos na lista
 *     Se numElem for positivo avan√ßa em dire√ß√£o ao final
 *     Se numElem for negativo avan√ßa em dire√ß√£o ao in√≠cio
 *     numElem pode ser maior do que o n√∫mro de elementos existentes na
 *               dire√ß√£o desejada
 *     Se numElem for zero somente verifica se a lista est√° vazia
 *
 *  $EP Par√¢metros
 *     pLista  - ponteiro para a lista a ser manipulada
 *     numElem - o n√∫mero de elementos a andar
 *
 *  $FV Valor retornado
 *     CondRetOK         - se numElem elementos tiverem sido andados
 *     CondRetFimLista   - se encontrou o fim da lista antes de andar numElem
 *                         elementos
 *     CondRetListaVazia - se a lista est√° vazia
 *
 ***********************************************************************/



LIS_tpCondRet LIS_AvancarElementoCorrente( LIS_tppLista pLista ,
                                          
                                          int numElem ) ;





/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Procurar elemento contendo valor
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Procura o elemento que referencia o valor dado.
 *     A fun√ß√£o compara ponteiro e n√£o conte√∫do apontado.
 *
 *  $EP Par√¢metros
 *     pLista  - ponteiro para a lista onde procura
 *     pValor  - ponteiro para o valor procurado
 *               Pode ser NULL
 *
 *  $FV Valor retornado
 *     LIS_CondRetOK  - se encontrou.
 *                      O elemento corrente √© o primeiro elemento do
 *                      elemento corrente inclusive para o fim da lista
 *                      e que cont√©m o ponteiro procurado
 *
 *     LIS_CondRetNaoEncontrou - se o ponteiro n√£o foi encontrado
 *                      O elemento corrente continua o mesmo
 *     LIS_CondRetListaVazia   - se a lista estiver vazia
 *
 ***********************************************************************/



LIS_tpCondRet LIS_ProcurarValor( LIS_tppLista pLista ,
                                
                                void * pValor        ) ;





/***********************************************************************
 *
 *  $FC Fun√ß√£o: LIS  &Get Numero De Elementos
 *
 *  $ED Descri√ß√£o da fun√ß√£o
 *     Obtem o numero de elementos da lista
 *
 *  $EP Par√¢metros
 *     pLista  - ponteiro para a lista de onde se quer o dado
 *
 *  $FV Valor retornado
 *     int - numeros de elementos contidos na lista
 *
 ***********************************************************************/



int LIS_GetNumElem(LIS_tppLista pLista);


/***********************************************************************
*
*  $FC FunÁ„o: LIS  &Verificar uma Lista
*
*  $ED DescriÁ„o da funÁ„o
*     FunÁ„o da interface de teste.
*     Verifica completamente uma determinada lista.
*     TambÈm marca todos os espaÁos por ela ocupados.
*
***********************************************************************/

#ifdef _DEBUG

   LIS_tpCondRet LIS_VerificarLista( void * pLista ) ;

#endif



/***********************************************************************
*
*  $FC FunÁ„o: LIS  &Verificar um cabeÁa da lista
*
*  $ED DescriÁ„o da funÁ„o
*     FunÁ„o da interface de teste.
*     Verifica a integridade de um a cabeca da lista.
*
*  $EP Par‚metros
*     $P pCabecaParm - ponteiro para um espaÁo que deveria ser uma cabeÁa
*                      de lista.
*
*  $FV Valor retornado
*     CondiÁ„o de retorno de teste
*
***********************************************************************/

#ifdef _DEBUG

   LIS_tpCondRet LIS_VerificarCabeca( void * pCabecaParm ) ;

#endif



/***********************************************************************
*
*  $FC FunÁ„o: LIS  &Verificar um elemento
*
*  $ED DescriÁ„o da funÁ„o
*     FunÁ„o da interface de teste.
*     Verifica a integridade de um elemento de lista.
*
*  $EP Par‚metros
*     $P pElem - ponteiro para um espaÁo que deveria ser um elemento de lista.
*
*  $FV Valor retornado
*     CondiÁ„o de retorno de teste
*
***********************************************************************/

#ifdef _DEBUG

   LIS_tpCondRet LIS_VerificarElemLista( void * pElem ) ;

#endif



/***********************************************************************
*
*  $FC FunÁ„o: LIS  &Deturpar lista
*
*  $ED DescriÁ„o da funÁ„o
*     FunÁ„o da interface de teste.
*     Corrompe elementos especÌficos da estrutura da lista.
*     Essa funÁ„o destina-se a preparar os cen·rios de teste dos
*     casos de teste utilizados ao testar os verificadores estruturais
*     da lista.
*     Esta funÁ„o n„o tem proteÁ„o contra erros de uso, consequentemente
*     poder· levar o programa a ser cancelado pelo sistema operacional.
*
*  $EP Par‚metros
*     $P pListaParm  - lista a ser deturpada
*     $P ModoDeturpar - identifica como deve ser feita a deturpaÁ„o
*                       LIS_tpModosDeturpacao identifica os modos de
*                       deturpaÁ„o conhecidos
*
***********************************************************************/

#ifdef _DEBUG

   void LIS_Deturpar( void * pListaParam ,
                      LIS_tpModosDeturpacao ModoDeturpar ) ;

#endif


#undef LISTA_EXT



/********** Fim do m√≥dulo de defini√ß√£o: LIS  Lista duplamente encadeada **********/

#else

#endif
